#include <gtest/gtest.h>

#include "test_common.h"
#include <fmt/ostream.h>
#include <stdexcept>
#include <tula/config/core.h>
#include <tula/config/yamlconfig.h>
#include <tula/logging.h>

namespace {

using namespace tula::testing;

// clang-format off
auto citlali_config = R"abcdefgh(# vim: et ts=2 sts=2 sw=2
---
description: |-
  This file is generated by tolteca.reduce
inputs:
- meta:
    name: example_simu
  data_items:
    - filepath: example_simu/toltec0_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec0'
        sweep_filepath: example_simu/toltec0_tune.nc
    - filepath: example_simu/toltec1_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec1'
        sweep_filepath: example_simu/toltec1_tune.nc
    - filepath: example_simu/toltec2_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec2'
        sweep_filepath: example_simu/toltec2_tune.nc
    - filepath: example_simu/toltec3_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec3'
        sweep_filepath: example_simu/toltec3_tune.nc
    - filepath: example_simu/toltec4_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec4'
        sweep_filepath: example_simu/toltec4_tune.nc
    - filepath: example_simu/toltec5_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec5'
        sweep_filepath: example_simu/toltec5_tune.nc
    - filepath: example_simu/toltec6_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec6'
        sweep_filepath: example_simu/toltec6_tune.nc
    - filepath: example_simu/toltec7_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec7'
        sweep_filepath: example_simu/toltec7_tune.nc
    - filepath: example_simu/toltec8_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec8'
        sweep_filepath: example_simu/toltec8_tune.nc
    - filepath: example_simu/toltec9_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec9'
        sweep_filepath: example_simu/toltec9_tune.nc
    - filepath: example_simu/toltec10_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec10'
        sweep_filepath: example_simu/toltec10_tune.nc
    - filepath: example_simu/toltec11_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec11'
        sweep_filepath: example_simu/toltec11_tune.nc
    - filepath: example_simu/toltec12_000003_000_0000_2021_06_25_18_50_06_timestream.nc
      meta:
        interface: 'toltec12'
        sweep_filepath: example_simu/toltec12_tune.nc
    - filepath: example_simu/tel_000003_000_0000_2021_06_25_18_50_06.nc
      meta:
        interface: 'lmt'
  cal_items:
    - filepath: example_simu/apt_000003_000_0000_2021_06_25_18_50_06_edited.ecsv
      type: array_prop_table
    - type: some_type
      some_key: some_value
- test:
    some: value
kids:
  fitter:
    modelspec: gainlintrend
    weight_window:
      fwhm_Hz: 1.5e4
      type: lorentz
  solver:
map:
  grouping: array_name
  mgrid0: 0.0
  mgrid1: 0.0
  pixelsize: 5.0
  type: RaDec
  timechunk: 1.0
  offset: 0.125
beammap:
  max_iterations: 1
  cutoff: 0.01
runtime:
  ncores: 8
  output_filepath: /Users/mmccrackan/toltec/temp/
  policy: omp
tod:
  despike:
    despikewindow: 32
    enabled: false
    sigma: 8.0
    timeconstant: 0.015
  downsample:
    downsamplefactor: 1
    enabled: true
  filter:
    agibbs: 50.0
    enabled: false
    fhigh: 4.0
    flow: 0.0
    nterms: 32
  kernel:
    enabled: true
  pcaclean:
    approximateWeights: false
    cutStd: 0.0
    enabled: false
    grouping: array_name
    neigToCut: 9
)abcdefgh";
// clang-format on

TEST(yamlconfig, get) {

    using namespace tula::config;

    std::stringstream ss;
    ss << citlali_config;

    auto node = YAML::Load(ss);
    fmtlog("node:\n{}", YAML::Dump(node));

    auto config = YamlConfig(node);

    fmtlog("config:\n{}", config);

    fmtlog(".[inputs][0][meta][name]={}",
           config.get_node(std::tuple{"inputs", 0, "meta", "name"})
               .template as<std::string>());

    auto key = std::tuple{"inputs", 0, "meta", "name"};
    fmtlog(".[inputs][0][meta][name]={}",
           config.get_node(key).template as<std::string>());
    // auto &n = config.get_node(key);
    // n = 1;
    // fmtlog("after modify .[inputs][0][meta][name]={}",
    //        config.get_node(key).template as<int>());
    EXPECT_TRUE(config.has("inputs"));
    EXPECT_TRUE(config.has(std::tuple{"inputs", 0}));
    EXPECT_FALSE(config.has(std::tuple{"inputs", "a"}));
    // EXPECT_TRUE(config.has_list(std::tuple{"inputs"}));
    EXPECT_EQ(config.get_node(std::tuple{"inputs"}), config.get_node("inputs"));
    EXPECT_EQ(config.get_node(std::tuple{"inputs", 0}), node["inputs"][0]);
    EXPECT_TRUE(config.has_typed<std::string>("description"));
    EXPECT_EQ(config.get_typed<int>(std::tuple{"runtime", "ncores"}), 8);
    EXPECT_EQ(config.get_str(std::tuple{"tod", "pcaclean", "grouping"}),
              "array_name");
    EXPECT_EQ(config.get_filepath(std::tuple{"runtime", "output_filepath"}),
              "/Users/mmccrackan/toltec/temp/");
    auto sc = config.get_config(std::tuple{"runtime"});
    EXPECT_EQ(sc.get_filepath("output_filepath"),
              "/Users/mmccrackan/toltec/temp/");
}

template <typename Derived>
using ConfigMapper =
    tula::config::ConfigValidatorMixin<Derived, tula::config::YamlConfig>;

struct ArrayPropTable : ConfigMapper<ArrayPropTable> {
    using Base = ConfigMapper<ArrayPropTable>;
    ArrayPropTable(config_t config, bool check = true)
        : Base{std::move(config), check},
          m_filepath(this->config().get_str("filepath")) {}
    static auto check_config(config_t &config) -> std::optional<std::string> {
        std::vector<std::string> missing_keys;
        SPDLOG_TRACE("check array prop table config\n{}", config);
        if (!config.has("filepath")) {
            missing_keys.emplace_back("filepath");
        }
        if (missing_keys.empty()) {
            return std::nullopt;
        }
        return fmt::format("invalid or missing keys={}", missing_keys);
    }
    const std::string &filepath() const { return m_filepath; }

    template <typename OStream>
    friend auto operator<<(OStream &os, const ArrayPropTable &d)
        -> decltype(auto) {
        return os << fmt::format("ArrayPropTable(filepath={})", d.filepath());
    }

private:
    std::string m_filepath{};
};

TEST(yamlconfig, validate) {

    using namespace tula::config;

    std::stringstream ss;
    ss << citlali_config;

    auto config = YamlConfig(YAML::Load(ss));

    auto apt = ArrayPropTable(
        config.get_config(std::tuple{"inputs", 0, "cal_items", 0}));
    fmtlog("apt: {}", apt);

    auto apt2 = ArrayPropTable::from_config(
        config.get_config(std::tuple{"inputs", 0, "cal_items", 0}));
    fmtlog("apt2: {}", apt2);

    auto apt3 = ArrayPropTable::from_config(
        config.get_config(std::tuple{"inputs", 0, "cal_items", 0}), false);
    fmtlog("apt3: {}", apt3);

    try {
        auto apt4 = ArrayPropTable::from_config(
            config.get_config(std::tuple{"inputs", 0, "cal_items", 1}));
    } catch (const std::runtime_error &e) {
        fmtlog("apt4 error: {}", e.what());
    }
}

} // namespace
